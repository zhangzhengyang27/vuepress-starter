第1章介绍了用Node做异步开发跟传统的同步开发有什么不同。本章会创建一个事件驱动的聊天小程序，让你通过实战了解Node。如果这一章里的某些细节让你觉得很晕，先不要担心。我们只是想揭开Node开发的神秘面纱，让你提前看看读完这本书后你能做些什么样的程序。

本章内容假定你有Web程序开发的经验，对HTTP有基本的认识，并且熟悉jQuery。随着本章内容逐步展开，你将：

- 游览这个程序，了解它是如何工作的；
- 审查技术需求，并完成程序的初始设置；
- 提供程序所需的HTML、CSS和客户端JavaScript； 
- 用Socket.IO处理跟聊天相关的消息；
- 用客户端JavaScript做程序的UI。

我们先从程序的概览开始，看看这个程序长什么样，以及等完成后它的表现如何。

## 2.1 程序概览

本章会构建一个在线聊天程序，用户可以在一个简单的表单中输入消息，相互聊天，如图2-1所示。消息输入后会发送给同一个聊天室内的其他所有用户。

![image-20220521210904580](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/myBlog/image-20220521210904580.png)

进入聊天室后，程序会自动给用户分配一个昵称，但他们可以用聊天命令修改自己的昵称，如图2-2所示。聊天命令以斜杠（/）开头。

![image-20220521210941685](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/myBlog/image-20220521210941685.png)

同样，用户也可以输入命令创建新的聊天室（或加入已有的聊天室），如图2-3所示。在加入或创建聊天室时，新聊天室的名称会出现在聊天程序顶端的水平条上，也会出现在聊天消息区域右侧的可用房间列表中。

![image-20220521211111936](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/myBlog/image-20220521211111936.png)

在用户换到新房间后，系统会确认这一变化，如图2-4所示。

![image-20220521211208623](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/myBlog/image-20220521211208623.png)

虽然从功能上看这个程序充其量只能算一个准系统，但它已经可以展示构建实时Web程序所需的重要组件和基本技术了。这个程序表明了Node如何同时处理传统的HTTP数据（比如静态文件）和实时数据（聊天消息）。通过它还能看出Node程序是如何组织的，以及依赖项是如何管理的。

现在我们来看看实现这个程序需要哪些技术。

## 2.2 程序需求及初始设置

将要创建的聊天程序需要完成如下任务：

- 提供静态文件（比如HTML、CSS和客户端JavaScript）；
- 在服务器上处理与聊天相关的消息；
- 在用户的浏览器中处理与聊天相关的消息。

为了提供静态文件，需要使用Node内置的http模块。但通过HTTP提供文件时，通常不能只是发送文件中的内容，还应该有所发送文件的类型。也就是说要用正确的MIME类型设置HTTP头的Content-Type。为了查找这些MIME类型，你会用到第三方的模块mime。

> MIME类型 MIME类型在维基百科上的文章http://en.wikipedia.org/wiki/MIME中有详细论述。

为了处理与聊天相关的消息，需要用Ajax轮询服务器。但为了让这个程序能尽可能快地做出响应，我们不会用传统的Ajax发送消息。Ajax用HTTP作为传输机制，并且HTTP本来就不是做实时通信的。在用HTTP发送消息时，必须用一个新的TCP/IP连接。打开和关闭连接需要时间。此外，因为每次请求都要发送HTTP头，所以传输的数据量也比较大。这个程序没用依赖于HTTP的方案，而是采用了 [WebSocket](http://en.wikipedia.org/wiki/WebSocket)这是一个为支持实时通讯而设计的轻量的双向通信协议。

因为在大多数情况下，只有兼容HTML5的浏览器才支持WebSocket，所以这个程序会使用流行的Socket.IO库（http://socket.io/），它给不能使用WebSocket的浏览器提供了一些后备措施，包括使用Flash。Socket.IO对后备功能的处理是透明的，不需要额外的代码或配置。第13章对Socket.IO做了更深入的介绍。

在开始做程序的文件结构和依赖项设置这些真正的初期工作之前，我们先聊聊Node如何同时处理HTTP和WebSocket，这是选它做实时程序最好的理由之一。

### 2.2.1 提供HTTP和WebSocket服务

尽管这个程序不会用Ajax发送和接收聊天消息，但它仍要用HTTP发送用在用户浏览器中的HTML、CSS和客户端JavaScript。

如图2-5所示，Node用一个端口就可以轻松地提供HTTP和WebSocket两种服务。Node带有一个可以提供HTTP服务功能的模块。还有一些第三方的Node模块，比如构建在Node内置功能上的Express，它让Web服务变得更加容易了。我们将在第8章深入探讨如何用Express构建Web程序。然而在本章的程序中，还是以介绍基础知识为主。

![image-20220521211706919](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/myBlog/image-20220521211706919.png)

现在你对程序要用的核心技术已经有了大概的认识，让我们把它充实起来。

### 2.2.2 创建程序的文件结构

在开始这个教程前，我们先为它创建一个项目目录。主程序文件会直接放在这个目录下。你需要添加一个lib子目录，用来放一些服务端逻辑。还需要创建一个public子目录，用来放客户端文件。在public子目录下，创建一个javascripts子目录和一个stylesheets目录。

现在你的目录结构看起来应该像图2-6一样。注意，我们决定在本章中用这种特别的方式组织程序中的文件。Node对目录结构没有任何特殊要求，你可以根据自己的喜好随意组织程序文件。

![image-20220521212754234](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/myBlog/image-20220521212754234.png)

现在你已经确立了程序的目录结构，接下来该指明它的依赖项了。程序的依赖项，在这里是指需要通过安装，来提供程序所需功能的模块。这么说吧，比如你正在创建的程序需要访问存放在MySQL数据库中的数据，可Node中没有可以访问MySQL的内置模块，所以你只能装一个第三方模块，这个模块就是我们所说的依赖项。

### 2.2.3 指明依赖项

尽管不正式指明依赖项也可以创建Node程序，但花点时间明确一下是个好习惯。这样，如果其他人要使用你的程序，或者你计划在多个地方运行它时，设置起来就要简单直接得多。

程序的依赖项是在package.json文件中指明的。这个文件总是被放在程序的根目录下。package.json文件用于描述你的应用程序，它包含一些JSON表达式，并遵循CommonJS包描述标准（http://wiki.commonjs.org/wiki/Packages/1.0）。

在package.json文件中可以定义很多事情，但最重要的是程序的名称、版本号、对程序的描述，以及程序的依赖项。

代码清单2-1中是一个包描述文件，描述了这个培训程序的功能和依赖项。将这个文件保存到培训程序的根目录中，命名为package.json。

![image-20220521212925111](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/myBlog/image-20220521212925111.png)

如果你看不太懂这个文件，不要担心，下一章还会介绍package.json文件，并且在第14章还会深入探讨它。

### 2.2.4 安装依赖项

定义好package.json文件之后，安装程序的依赖项就是小菜一碟了。Node包管理器（npm，

https://github.com/isaacs/npm）是Node自带的工具，它有很多功能，可以轻松安装第三方Node模块，可以把你自己创建的任何Node模块向全球发布。它用一行命令就能从package.json文件中读出依赖项，把它们都装好。

在教程的根目录下输入下面这条命令：

```js
npm i
```

再看这个目录，你应该能看到一个新创建的node_modules目录，目录结构已经确立了，依赖项也装好了，可以开始填充程序逻辑了。

## 2.3 提供 HTML、CSS 和客户端 JavaScript 的服务

就像之前列出来的，聊天程序需要具备三个基本功能：

- 给用户的Web浏览器提供静态文件；
- 在服务器端处理与聊天相关的消息；
- 在用户的Web浏览器中处理与聊天相关的消息。

程序的逻辑是由一些文件实现的，有些运行在服务器上，有些运行在客户端，如图2-8所示。

在客户端运行的JavaScript需要作为静态资源发给浏览器，而不是在Node上执行。

![image-20220521213048208](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/myBlog/image-20220521213048208.png)

本节要先解决第一个需求，我们会定义提供静态文件所需的逻辑。然后添加静态的HTML和CSS文件。

### 2.3.1 创建静态文件服务器

创建静态文件服务器既要用到Node内置的功能，也要用第三方的mime附加模块来确定文件的的MIME类型。

先从程序的主文件开始，请在项目根目录下创建server.js文件，把代码清单2-2中的变量声明放到这个文件中。有了这些声明，你就可以使用Node中跟HTTP相关的功能、跟文件系统交互的功能，以及确定文件MIME类型的功能。变量cache是用来缓存文件中的数据的。

![image-20220521213311601](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/myBlog/image-20220521213311601.png)

#### 1.发送文件数据及错误响应

接下来要添加三个辅助函数以提供静态HTTP文件服务。第一个是在所请求的文件不存在时发送404错误的。把下面的辅助函数加到server.js中：

![image-20220521213408411](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/myBlog/image-20220521213408411.png)

第二个辅助函数提供文件数据服务。这个函数先写出正确的HTTP头，然后发送文件的内容。把下面的代码添加到server.js中：

![image-20220521213447941](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/myBlog/image-20220521213447941.png)

访问内存（RAM）要比访问文件系统快得多，所以Node程序通常会把常用的数据缓存到内存里。我们的聊天程序就要把静态文件缓存到内存中，只有第一次访问的时候才会从文件系统中读取。下一个辅助函数会确定文件是否缓存了，如果是，就返回它。如果文件还没被缓存，它会从硬盘中读取并返回它。如果文件不存在，则返回一个HTTP 404错误作为响应。把这个辅助函数加到server.js中：

![image-20220521213548932](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/myBlog/image-20220521213548932.png)

#### 2.创建HTTP服务器

在创建HTTP服务器时，需要给createServer传入一个匿名函数作为回调函数，由它来处理每个HTTP请求。这个回调函数接受两个参数：request和response。在这个回调执行时，HTTP服务器会分别组装这两个参数对象，以便你可以对请求的细节进行处理，并返回一个响应。第4章会深入介绍http模块。

将下面代码清单中的逻辑添加到server.js中以创建HTTP服务器。

![image-20220521213658289](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/myBlog/image-20220521213658289.png)

#### 3.启动HTTP服务器

现在你已经写好了创建HTTP服务器的代码，但还没添加启动它的逻辑。添加下面这些代码，它会启动服务器，要求服务器监听TCP/IP端口3000。3000是随便选的，所有1024以上的未用端口应该都可以（如果在Windows上运行，1024以下的端口也行，或者在Linux及OS X中用“root”这样的特权用户启动程序也可以）。

```js
server.listen(3000,function(){
  	console.log("Server listening on port 3000")
})
```

如果你想看看这个程序现在能做什么，可以在命令行中输入下面这条命令启动服务器：

```js
node server.js
```

服务器运行起来后，在浏览器中访问http://127.0.0.1:3000会激发404错误辅助函数，页面上会显示“Error 404: resource not found。”消息。尽管你已经添加了静态文件处理逻辑，但还没添加那些静态文件。记住，在命令行中按下Ctrl-C可以停止正在运行的服务器。

接下来，让我们把必须的静态文件加上，把这个聊天程序的功能再向前推进一步。

### 2.3.2 添加HTML和CSS文件

你要加的第一个静态文件是默认的HTML文件。在public目录下创建index.html文件，把代码清单2-5中的HTML放进去。这段HTML会引入一个CSS文件，设置一些显示程序内容的div元素，加载一些客户端JavaScript文件。这些JavaScript文件提供了客户端Socket.IO功能、jQuery（用来操作DOM），以及两个该程序特有的文件，用来提供聊天功能。

代码清单2-5 聊天程序的HTML

```html
<!doctype html>
<html lang='en'>

<head>
  <title>Chat</title>
  <link rel='stylesheet' href='/stylesheets/style.css'></link>
</head>

<body>
<div id='content'>
  <div id='room'></div>
  <!-- 显示当前可用的聊天室列表的div -->
  <div id='room-list'></div>
  <!-- 显示聊天消息的div -->
  <div id='messages'></div>

  <form id='send-form'>
    <input id='send-message' />
    <input id='send-button' type='submit' value='Send'/>

    <div id='help'>
      Chat commands:
      <ul>
        <li>Change nickname: <code>/nick [username]</code></li>
        <li>Join/create room: <code>/join [room name]</code></li>
      </ul>
    </div>
  </form>
</div>

<script src='/socket.io/socket.io.js' type='text/javascript'></script>
<script src='http://code.jquery.com/jquery-1.8.0.min.js' type='text/javascript'></script>
<script src='/javascripts/chat.js' type='text/javascript'></script>
<script src='/javascripts/chat_ui.js' type='text/javascript'></script>
</body>
</html>
```

下一个要添加的是定义程序页面样式的CSS文件。在public/stylesheets目录下创建style.css文件，把下面的CSS代码放进去。

代码清单2-6 程序的CSS 

```css
body {
  padding: 50px;
  font: 14px "Lucida Grande", Helvetica, Arial, sans-serif;
}

a {
  color: #00B7FF;
}

#content {
  width: 800px;
  margin-left: auto;
  margin-right: auto;
}

#room {
  background-color: #ddd;
  margin-bottom: 1em;
}

#messages {
  width: 690px;
  height: 300px;
  overflow: auto;
  background-color: #eee;
  margin-bottom: 1em;
  margin-right: 10px;
}

#room-list {
  float: right;
  width: 100px;
  height: 300px;
  overflow: auto;
}

#room-list div {
  border-bottom: 1px solid #eee;
}

#room-list div:hover {
  background-color: #ddd;
}

#send-message {
  width: 700px;
  margin-bottom: 1em;
  margin-right: 1em;
}

#help {
  font: 10px "Lucida Grande", Helvetica, Arial, sans-serif;
}

```

现在HTML和CSS基本做好了，运行程序，用浏览器看一下，应该能看到如图2-9所示的界面。这个程序还不能用，但静态文件已经可以看了，基本的视觉布局也搭建好了。把这些料理好了之后，我们接下来去定义服务端聊天消息的分发。

<img src="https://interview-aliyun.oss-cn-beijing.aliyuncs.com/myBlog/image-20220522115228318.png" alt="image-20220522115228318" style="zoom:50%;" />

## 2.4 用 Socket.IO 处理与聊天相关的消息

我们前面说过程序必须要做三件事，其中第一个提供静态文件已经做了，现在来解决第二个，处理浏览器和服务器之间的通信。现代浏览器能用WebSocket处理浏览器跟服务器两者之间的通信（参见Socket.IO浏览器支持页以了解详情：http://socket.io/#browser-support）。

Socket.IO为Node及客户端JavaScript提供了基于WebSocket以及其他传输方式的封装，它提供了一个抽象层。如果浏览器没有实现WebSocket，Socket.IO会自动启用一个备选方案，而对外提供的API还是一样的。本节将会：

- 简要介绍下Socket.IO，并确定要在服务器端使用的Socket.IO功能；
- 添加代码设置Socket.IO服务器；
- 添加代码处理各种聊天程序的事件。

Socket.IO提供了开箱即用的虚拟通道，所以程序不用把每条消息都向已连接的用户广播，而是只向那些预订了某个通道的用户广播。用这个功能实现程序里的聊天室非常简单，很快你就能看到。

Socket.IO还是事件发射器（Event Emitter）的好例子。事件发射器本质上是组织异步逻辑的一种很方便的设计模式。本章中会有一些事件发射器的代码，但下一章才会做更深入的讨论。

>事件发射器是跟某种资源相关联的，它能向这个资源发送消息，也能从这个资源接收消息。资源可以连接远程服务器，或者更抽象的东西，比如游戏中的角色。Johnny-Five项目（https://github.com/rwldrn/johnny-five）是一个用Node做的机器人程序，实际上就是用事件发射器控制Arduino微控制器。

我们先开始做服务器上的功能，并确立处理连接的逻辑。然后会定义服务端所需的功能。

### 2.4.1 设置Socket.IO服务器

首先，把下面这两行代码添加到server.js中。第一行加载一个定制的Node模块，它提供的逻辑是用来处理基于Socket.IO的服务端聊天功能的，我们在后文中再定义这个模块。第二行启动Socket.IO服务器，给它提供一个已经定义好的HTTP服务器，这样它就能跟HTTP服务器共享同一个TCP/IP端口：

```js
var chatServer=require('./1ib/chat_server');
chatServer.listen (server);
```

现在你要在lib目录中创建一个新文件，chat_server.js。先把下面的变量声明添加到这个文件中。这些声明让我们可以使用Socket.IO，并初始化了一些定义聊天状态的变量：

```js
var socketio = require('socket.io');
var io;
var guestNumber = 1;
var nickNames = {};
var namesUsed = [];
var currentRoom = {};
```

确立连接逻辑

接下来添加代码清单2-7中的逻辑，定义聊天服务器函数listen。server.js中会调用这个函数。

它启动Socket.IO服务器，限定Socket.IO向控制台输出的日志的详细程度，并确定该如何处理每个接进来的连接。

你应该注意到了，连接处理逻辑调用了几个辅助函数，现在你可以把它们添加到chat_server.js中。

代码清单2-7 启动Socket.IO服务器

```js
exports.listen = function(server) {
  // 启动Socket.IO服务器，允许它搭载在已有的HTTP 服 务器上
  io = socketio.listen(server);
  io.set('log level', 1);
  
  // 定义每个用户连接的处理逻辑
  io.sockets.on('connection', function (socket) {
    // 在用户连接上来时赋予其一个访客名
    guestNumber = assignGuestName(socket, guestNumber, nickNames, namesUsed);
    // 在用户连接上来时把他放入聊天室Lobby里
    joinRoom(socket, 'Lobby');
    // 处理用户的消息，更名，以及聊天室的创建和变更
    handleMessageBroadcasting(socket, nickNames);
    handleNameChangeAttempts(socket, nickNames, namesUsed);
    handleRoomJoining(socket);
    // 用户发出请求时，向其提供已经被占用的聊天室的列表
    socket.on('rooms', function() {
      socket.emit('rooms', io.sockets.manager.rooms);
    });
    // 定义用户断开连接后的清除逻辑
    handleClientDisconnection(socket, nickNames, namesUsed);
  });
};
```

我们已经确立了连接处理逻辑，现在该添加用来处理程序需求的所有辅助函数了。

### 2.4.2 处理程序场景及事件

聊天程序需要处理下面这些场景和事件：

- 分配昵称；
- 房间更换请求；
- 昵称更换请求；
- 发送聊天消息；
- 房间创建；
- 用户断开连接。

要实现这些功能得添加几个辅助函数，如下文所述。

#### 1.分配昵称

要添加的第一个辅助函数是assignGuestName，用来处理新用户的昵称。当用户第一次连到聊天服务器上时，用户会被放到一个叫做Lobby的聊天室中，并调用assignGuestName给他们分配一个昵称，以便可以相互区分开。

程序分配的所有昵称基本上都是在Guest后面加上一个数字，有新用户连进来时这个数字就会往上增长。用户昵称存在变量nickNames中以便于引用，并且会跟一个内部socket ID关联。昵称还会被添加到namesUsed中，这个变量中保存的是已经被占用的昵称。把下面清单中的代码添加到lib/chat_server.js中实现这个功能。

代码清单2-8 分配用户昵称

```js
function assignGuestName(socket, guestNumber, nickNames, namesUsed) {
  var name = 'Guest' + guestNumber;
  // 把用户昵称跟客户端连接 ID关联上
  nickNames[socket.id] = name;
  // 让用户知道他们的昵称
  socket.emit('nameResult', {
    success: true,
    name: name
  });
  // 存放已经被占用的昵称
  namesUsed.push(name);
  // 增加用来生成昵称的计数器
  return guestNumber + 1;
}
```

#### 2.进入聊天室

要添加到chat_server.js中的第二个辅助函数是joinRoom。这个函数如代码清单2-9所示，处理逻辑跟用户加入聊天室相关。

代码清单2-9 与进入聊天室相关的逻辑

```js
function joinRoom(socket, room) {
  // 让用户进入房间
  socket.join(room);
  // 记录用户的当前房间
  currentRoom[socket.id] = room;
  // 让用户知道他们进入了新的房间
  socket.emit('joinResult', {room: room});
  // 让房间里的其他用户知道有新用户进入了房间
  socket.broadcast.to(room).emit('message', {
    text: nickNames[socket.id] + ' has joined ' + room + '.'
  });
	
  // 确定有哪些用户在这个房间里
  var usersInRoom = io.sockets.clients(room);
  // 如果不止一个用户在这个房间里，汇总下都是谁
  if (usersInRoom.length > 1) {
    var usersInRoomSummary = 'Users currently in ' + room + ': ';
    for (var index in usersInRoom) {
      var userSocketId = usersInRoom[index].id;
      if (userSocketId != socket.id) {
        if (index > 0) {
          usersInRoomSummary += ', ';
        }
        usersInRoomSummary += nickNames[userSocketId];
      }
    }
    usersInRoomSummary += '.';
    // 将房间里其他用户的汇总发送给这个用户
    socket.emit('message', {text: usersInRoomSummary});
  }
}
```

将用户加入Socket.IO房间很简单，只要调用socket对象上的join方法就行。然后程序就会把相关细节向这个用户及同一房间中的其他用户发送。程序会让用户知道有哪些用户在这个房间里，还会让其他用户知道这个用户进来了。

#### 3.处理昵称变更请求

如果用户都用程序分配的昵称，很难记住谁是谁。因此聊天程序允许用户发起更名请求。

如图2-10所示，更名需要用户的浏览器通过Socket.IO发送一个请求，并接收表示成功或失败的响应。

![image-20220522121240755](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/myBlog/image-20220522121240755.png)

将下面代码清单中的代码加到lib/chat_server.js中，这段代码定义了一个处理用户更名请求的函数。从程序的角度来讲，用户不能将昵称改成以Guest开头，或改成其他已经被占用的昵称。

代码清单2-10 更名请求的处理逻辑

```js
function handleNameChangeAttempts(socket, nickNames, namesUsed) {
  // 添 加 nameAtte-mpt事件的监听器
  socket.on('nameAttempt', function(name) {
    // 昵称不能以Guest开头
    if (name.indexOf('Guest') == 0) {
      socket.emit('nameResult', {
        success: false,
        message: 'Names cannot begin with "Guest".'
      });
    } else {
      if (namesUsed.indexOf(name) == -1) {
        var previousName = nickNames[socket.id];
        var previousNameIndex = namesUsed.indexOf(previousName);
        namesUsed.push(name);
        nickNames[socket.id] = name;
        // 删掉之前用的昵称，让其他用户可以使用
        delete namesUsed[previousNameIndex];
        socket.emit('nameResult', {
          success: true,
          name: name
        });
        socket.broadcast.to(currentRoom[socket.id]).emit('message', {
          text: previousName + ' is now known as ' + name + '.'
        });
      } else {
        // 如果昵称已经被占用，给客户端发送错误消息
        socket.emit('nameResult', {
          success: false,
          message: 'That name is already in use.'
        });
      }
    }
  });
}
```

#### 4.发送聊天消息

用户昵称没问题了，现在需要加个函数处理用户发过来的聊天消息。图2-11给出了基本流程：

用户发射一个事件，表明消息是从哪个房间发出来的，以及消息的内容是什么；然后服务器将这条消息转发给同一房间的所有用户。

![image-20220522121548150](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/myBlog/image-20220522121548150.png)

将下面的代码加到lib/chat_server.js中。Socket.IO的broadcast函数是用来转发消息的：

```js
function handleMessageBroadcasting(socket) {
  socket.on('message', function (message) {
    socket.broadcast.to(message.room).emit('message', {
      text: nickNames[socket.id] + ': ' + message.text
    });
  });
}
```

#### 5.创建房间

接下来要添加让用户加入已有房间的逻辑，如果房间还没有的话，则创建一个房间。图2-12是用户和服务器双方的交互。

将下面的代码添加到lib/chat_server.js文件中，实现更换房间的功能。注意Socket.IO中leave方法的使用：

```js
function handleRoomJoining(socket) {
  socket.on('join', function(room) {
    socket.leave(currentRoom[socket.id]);
    joinRoom(socket, room.newRoom);
  });
}
```

![image-20220522121802410](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/myBlog/image-20220522121802410.png)

#### 6.用户断开连接

最后还要把下面这段代码添加到lib/chat_server.js文件中，当用户离开聊天程序时，从nickNames和namesUsed中移除用户的昵称：

```js
function handleClientDisconnection(socket) {
  socket.on('disconnect', function() {
    var nameIndex = namesUsed.indexOf(nickNames[socket.id]);
    delete namesUsed[nameIndex];
    delete nickNames[socket.id];
  });
}
```

服务端的逻辑都已经做好了，现在可以回过头去继续做客户端的逻辑了。

## 2.5 在程序的用户界面上使用客户端 JavaScript 

在服务端分发浏览器发来的消息的Socket.IO逻辑已经加上了，现在该添加跟服务器通信所需要的客户端JavaScript了。客户端JavaScript需要实现以下功能：

- 向服务器发送用户的消息和昵称/房间变更请求；
- 显示其他用户的消息，以及可用房间的列表。

我们先从第一个功能开始。

### 2.5.1 将消息和昵称/房间变更请求传给服务器

要添加的第一段客户端JavaScript代码是一个JavaScript原型对象，用来处理聊天命令、发送消息、请求变更房间或昵称。

在public/javascripts目录下创建一个chat.js文件，把下面的代码放进去。这段代码相当于定义了一个JavaScript“类”，在初始化时可用传入一个Socket.IO的参数socket：

```js
var Chat = function(socket) {
  this.socket = socket;
};
```

接着添加这个发送聊天消息的函数:

```js
Chat.prototype.sendMessage = function(room, text) {
  var message = {
    room: room,
    text: text
  };
  this.socket.emit('message', message);
};
```

变更房间的函数

```js
Chat.prototype.changeRoom = function(room) {
  this.socket.emit('join', {
    newRoom: room
  });
};
```

最后添加下面代码清单中定义的函数，处理聊天命令。它能识别两个命令：join用来加入或创建一个房间，nick用来修改昵称。

代码清单2-11 处理聊天命令

```js
Chat.prototype.processCommand = function(command) {
  var words = command.split(' ');
  // 从第一个单词开始解析命令
  var command = words[0].substring(1, words[0].length).toLowerCase();
  var message = false;

  switch(command) {
    case 'join':
      words.shift();
      var room = words.join(' ');
      // 处理房间的变换/创建
      this.changeRoom(room);
      break;
    case 'nick':
      words.shift();
      var name = words.join(' ');
      // 处理更名尝试
      this.socket.emit('nameAttempt', name);
      break;
    default:
      // 如果命令无法识别，返回错误消息
      message = 'Unrecognized command.';
      break;
  };

  return message;
};
```

### 2.5.2 在用户界面中显示消息及可用房间

现在该添加使用jQuery跟用户界面（基于浏览器）直接交互的逻辑了。要添加的第一个功能是显示文本数据。

从安全角度来看，Web程序中有两种文本数据。一种是受信的文本数据，由程序提供的文本组成，另一种是可疑的文本数据，是由程序的用户创建的文本，或从用户创建的文本中提取出来的。我们之所以认为来自用户的文本数据是可疑的，是因为恶意用户可能会蓄意在提交的文本数据中包含`<script>`标签，放入JavaScript逻辑。如果不经修改就把这些数据展示给其他用户，可能会发生令人厌恶的事情，比如将用户转到其他Web页面上。这种劫持Web程序的方法称作跨域脚本（XSS）攻击。

这个聊天程序会用两个辅助函数显示文本数据。一个函数用来显示可疑的文本数据，另一个函数显示受信的文本数据。

函数divEscapedContentElement用来显示可疑的文本。它会净化文本，将特殊字符转换成HTML实体，如图2-13所示，这样浏览器就会按输入的样子显示它们，而不会试图按HTML标签解释它们。

![image-20220522122629335](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/myBlog/image-20220522122629335.png)

函数divSystemContentElement用来显示系统创建的受信内容，而不是其他用户创建的。在public/javascripts目录下创建chat_ui.js文件，并把下面两个辅助函数放进去：

```js
function divEscapedContentElement(message) {
  return $('<div></div>').text(message);
}

function divSystemContentElement(message) {
  return $('<div></div>').html('<i>' + message + '</i>');
}
```

下一个要加到chat_ui.js中的函数是用来处理用户输入的，具体内容见代码清单2-12。如果用户输入的内容以斜杠（/）开头，它会将其作为聊天命令处理。如果不是，就作为聊天消息发送给服务器并广播给其他用户，并添加到用户所在聊天室的聊天文本中。

代码清单2-12 处理原始的用户输入

```js
function processUserInput(chatApp, socket) {
  var message = $('#send-message').val();
  var systemMessage;
	// 如果用户输入的内容以斜杠（/）开头，将其作为聊天命令
  if (message.charAt(0) == '/') {
    systemMessage = chatApp.processCommand(message);
    if (systemMessage) {
      $('#messages').append(divSystemContentElement(systemMessage));
    }
  } else {
    // 将非命令输入广播给其他用户
    chatApp.sendMessage($('#room').text(), message);
    $('#messages').append(divEscapedContentElement(message));
    $('#messages').scrollTop($('#messages').prop('scrollHeight'));
  }

  $('#send-message').val('');
}
```

辅助函数现在已经定义好了，你还需要添加下面这个代码清单中的逻辑，它要在用户的浏览器加载完页面后执行。这段代码会对客户端的Socket.IO事件处理进行初始化。

```js
var socket = io.connect();

$(document).ready(function() {
  var chatApp = new Chat(socket);

  // 显示更名尝试的结果
  socket.on('nameResult', function(result) {
    var message;

    if (result.success) {
      message = 'You are now known as ' + result.name + '.';
    } else {
      message = result.message;
    }
    $('#messages').append(divSystemContentElement(message));
  });

  // 显示房间变更结果
  socket.on('joinResult', function(result) {
    $('#room').text(result.room);
    $('#messages').append(divSystemContentElement('Room changed.'));
  });

  // 显示接收到的消息
  socket.on('message', function (message) {
    var newElement = $('<div></div>').text(message.text);
    $('#messages').append(newElement);
  });

  // 显示可用房间列表
  socket.on('rooms', function(rooms) {
    $('#room-list').empty();

    for(var room in rooms) {
      room = room.substring(1, room.length);
      if (room != '') {
        $('#room-list').append(divEscapedContentElement(room));
      }
    }
		// 点击房间名可以换到那个房间中
    $('#room-list div').click(function() {
      chatApp.processCommand('/join ' + $(this).text());
      $('#send-message').focus();
    });
  });

  // 定期请求可用房间列表
  setInterval(function() {
    socket.emit('rooms');
  }, 1000);

  $('#send-message').focus();

  // 提交表单可以发送聊天消息
  $('#send-form').submit(function() {
    processUserInput(chatApp, socket);
    return false;
  });
});
```

接下来让我们把程序做完，将下面代码清单中的CSS样式代码添加到public/stylesheets /style.css文件中。

代码清单2-14 最后一点要加到style.css中的代码

```css
#room-list {
  float: right;
  width: 100px;
  height: 300px;
  overflow: auto;
}

#room-list div {
  border-bottom: 1px solid #eee;
}

#room-list div:hover {
  background-color: #ddd;
}

#send-message {
  width: 700px;
  margin-bottom: 1em;
  margin-right: 1em;
}

#help {
  font: 10px "Lucida Grande", Helvetica, Arial, sans-serif;
}
```

加好最后的代码，让我们把程序跑起来试试（用node server.js）。结果看起来应该像图2-14一样。

![image-20220522123323110](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/myBlog/image-20220522123323110.png)

## 2.6 小结

你已经用Node.js完成了一个小型的实时Web程序！

对于如何构建程序，以及代码看起来应该是什么样子，你现在应该有点感觉了。如果对这个示例程序的某些方面仍不清楚，请不要担心，我们在后续章节中会深入探讨这个例子中用到的工艺和技术。

然而在深入到Node的具体开发工作中之前，我们应该先学一学如何应对异步开发带来的独特挑战。下一章将教给你一些基本的技术和技巧，这能帮你节省大量时间，少走很多弯路。