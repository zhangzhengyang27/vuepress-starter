---
title: 基本概念下
date: '2022-05-19 20:23:00'
sidebar: 'auto'
categories:
 - 前端
 - JS
tags:
 - 高级
---



## 3.5 操作符

ECMA-262 描述了一组用于操作数据值的操作符，包括算术操作符（如加号和减号）、位操作符、关系操作符和相等操作符。

ECMAScript 操作符的与众不同之处在于，它们能够适用于很多值，例如字符串、数字值、布尔值，甚至对象。不过，在应用于对象时，相应的操作符通常都会调用对象的 valueOf()和（或）toString()方法，以便取得可以操作的值。

### 3.5.1 一元操作符

只能操作一个值的操作符叫做一元操作符。一元操作符是 ECMAScript 中最简单的操作符。



#### 递增和递减操作符

递增和递减操作符有两个版本：前置型和后置型。

前置型应该位于要操作的变量之前，而后置型则应该位于要操作的变量之后。

```js
var age = 29; 
++age; 

// 相同的执行效果
var age = 29; 
age = age + 1;
```

执行前置递减操作的方法也类似，结果会从一个数值中减去 1。age 变量的值就减少为 28（从 29 中减去了 1）

```js
var age = 29; 

--age;
```

由于前置递增和递减操作与执行语句的优先级相等，因此整个语句会从左至右被求值。再看一个例子：

```js
var num1 = 2; 
var num2 = 20; 

var num3 = --num1 + num2; // 等于 21 
var num4 = num1 + num2; // 等于 21 
```



后置型递增和递减操作符的语法不变（仍然分别是++和--），只不过要放在变量的后面而不是前面。

```js
var num1 = 2; 
var num2 = 20; 

var num3 = num1-- + num2; //等于22
var num4 = num1 + num2; // 等于 21 
```

所有这 4 个操作符对任何值都适用，也就是它们不仅适用于整数，还可以用于字符串、布尔值、浮点数值和对象。在应用于不同的值时，递增和递减操作符遵循下列规则。

- 在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减 1 的操作。字符串变量变成数值变量。
- 在应用于一个不包含有效数字字符的字符串时，将变量的值设置为 NaN（第 4 章将详细讨论）。字符串变量变成数值变量。
- 在应用于布尔值 false 时，先将其转换为 0 再执行加减 1 的操作。布尔值变量变成数值变量。
- 在应用于布尔值 true 时，先将其转换为 1 再执行加减 1 的操作。布尔值变量变成数值变量。
- 在应用于浮点数值时，执行加减 1 的操作。
- 在应用于对象时，先调用对象的 valueOf()方法以取得一个可供操作的值。然后对该值应用前述规则。如果结果是 NaN，则再调用 toString()方法后再应用前述规则。对象变量变成数值变量。

以下示例展示了上面的一些规则：

```js
var s1 = "2"; 
var s2 = "z"; 
var b = false; 
var f = 1.1; 
var o = { 
 valueOf: function() { 
 		return -1; 
 } 
}; 

s1++; // 值变成数值 3 
s2++; // 值变成 NaN 
b++; // 值变成数值 1 
f--; // 值变成 0.10000000000000009（由于浮点舍入错误所致）
o--; // 值变成数值-2
```



#### 一元加和减操作符

一元加操作符以一个加号（+）表示，放在数值前面，对数值不会产生任何影响，

```js
var num = 25; 
num = +num; // 仍然是 25 
```

不过，在对非数值应用一元加操作符时，该操作符会像 Number()转型函数一样对这个值执行转换。

对象是先调用它们的 valueOf()和（或）toString()方法，再转换得到的值。

```js
var s1 = "01"; 
var s2 = "1.1"; 
var s3 = "z"; 
var b = false; 
var f = 1.1; 
var o = { 
 	valueOf: function() { 
 		return -1; 
 	} 
}; 

s1 = +s1; // 值变成数值 1 
s2 = +s2; // 值变成数值 1.1 
s3 = +s3; // 值变成 NaN 

b = +b; // 值变成数值 0 
f = +f; // 值未变，仍然是 1.1 
o = +o; // 值变成数值-1 
```



一元减操作符主要用于表示负数，例如将 1 转换成-1。

```js
var num = 25; 

num = -num; // 变成了-25 
```

在将一元减操作符应用于数值时，该值会变成负数。而当应用于非数值时，一元减操作符遵循与一元加操作符相同的规则，最后再将得到的数值转换为负数

```js
var s1 = "01"; 
var s2 = "1.1"; 
var s3 = "z"; 
var b = false; 
var f = 1.1; 
var o = { 
 	valueOf: function() { 
 		return -1; 
 	} 
}; 

s1 = -s1; // 值变成了数值-1 
s2 = -s2; // 值变成了数值-1.1 
s3 = -s3; // 值变成了 NaN 

b = -b; // 值变成了数值 0 
f = -f; // 变成了-1.1 
o = -o; // 值变成了数值 1 
```

一元加和减操作符主要用于基本的算术运算，也可以像前面示例所展示的一样用于转换数据类型。



### 3.5.2 位操作符

位操作符用于在最基本的层次上，即按内存中表示数值的位来操作数值。

ECMAScript 中的所有数值都以 IEEE-754 64 位格式存储，但位操作符并不直接操作 64 位的值。而是先将 64 位的值转换成 32 位的整数，然后执行操作，最后再将结果转换回 64 位。对于开发人员来说，由于 64 位存储格式是透明的，因此整个过程就像是只存在 32 位的整数一样。

对于有符号的整数，32 位中的前 31 位用于表示整数的值。第 32 位用于表示数值的符号：0 表示正数，1 表示负数。这个表示符号的位叫做符号位，符号位的值决定了其他位数值的格式。其中，正数以纯二进制格式存储，31 位中的每一位都表示 2 的幂。

例如，数值 18 的二进制表示是00000000000000000000000000010010，或者更简洁的 10010。这是 5 个有效位，这 5 位本身就决定了实际的值（如图 3-1 所示）。

![image-20220521124718709](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/myBlog/image-20220521124718709.png)

负数同样以二进制码存储，但使用的格式是二进制补码。计算一个数值的二进制补码，需要经过下列 3 个步骤：

1. 求这个数值绝对值的二进制码（例如，要求-18 的二进制补码，先求 18 的二进制码）；
2. 求二进制反码，即将 0 替换为 1，将 1 替换为 0；
3. 得到的二进制反码加 1。

![image-20220521125012976](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/myBlog/image-20220521125012976.png)

这样，就求得了-18 的二进制表示，即 11111111111111111111111111101110。要注意的是，在处理有符号整数时，是不能访问位 31 的。

ECMAScript 会尽力向我们隐藏所有这些信息。换句话说，在以二进制字符串形式输出一个负数时，我们看到的只是这个负数绝对值的二进制码前面加上了一个负号。如下面的例子所示：

```js
var num = -18; 

alert(num.toString(2)); // "-10010" 
```

要把数值-18 转换成二进制字符串时，得到的结果是"-10010"。这说明转换过程理解了二进制补码并将其以更合乎逻辑的形式展示了出来。

>默认情况下，ECMAScript 中的所有整数都是有符号整数。不过，当然也存在无符号整数。对于无符号整数来说，第 32 位不再表示符号，因为无符号整数只能是正数。而且，无符号整数的值可以更大，因为多出的一位不再表示符号，可以用来表示数值。
>

在 ECMAScript 中，当对数值应用位操作符时，后台会发生如下转换过程：64 位的数值被转换成 32位数值，然后执行位操作，最后再将 32 位的结果转换回 64 位数值。这样，表面上看起来就好像是在操作 32 位数值，就跟在其他语言中以类似方式执行二进制操作一样。但这个转换过程也导致了一个严重的副效应，即在对特殊的 NaN 和 Infinity 值应用位操作时，这两个值都会被当成 0 来处理。

如果对非数值应用位操作符，会先使用 Number()函数将该值转换为一个数值（自动完成），然后再应用位操作。得到的结果将是一个数值。



#### 按位非（NOT）

按位非操作符 `~` 表示，执行按位非的结果就是返回数值的反码。按位非是ECMAScript 操作符中少数几个与二进制计算有关的操作符之一。下面看一个例子：

```js
var num1 = 25;    // 二进制 00000000000000000000000000011001 
var num2 = ~num1; // 二进制 11111111111111111111111111100110 

alert(num2); // -26 
```

<p style="color:red">这里，对 25 执行按位非操作，结果得到了-26。这也验证了按位非操作的本质：操作数的负值减 1。</p>



#### 按位与（AND）

按位与操作符 `&` 表示，从本质上讲，按位与操作就是将两个数值的每一位对齐，然后根据下表中的规则，对相同位置上的两个数执行 AND 操作：

![image-20220521125754399](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/myBlog/image-20220521125754399.png)

简而言之，按位与操作只在两个数值的对应位都是 1 时才返回 1，任何一位是 0，结果都是 0。

下面看一个对 25 和 3 执行按位与操作的例子：

```js
var result = 25 & 3; 

alert(result); //1 

//  25 = 0000 0000 0000 0000 0000 0000 0001 1001 
//  3  = 0000 0000 0000 0000 0000 0000 0000 0011 
------------------------------------------------ 
// AND = 0000 0000 0000 0000 0000 0000 0000 0001 
```



#### 按位或（OR）

按位或操作符 `|` ，同样也有两个操作数。按位或操作遵循下面这个真值表。

![image-20220521130001158](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/myBlog/image-20220521130001158.png)

按位或操作在有一个位是 1 的情况下就返回 1，而只有在两个位都是 0 的情况下才返回 0。

如果在前面按位与的例子中对 25 和 3 执行按位或操作，则代码如下所示：

```js
var result = 25 | 3; 

alert(result); //27 

// 25 = 0000 0000 0000 0000 0000 0000 0001 1001 
//  3 = 0000 0000 0000 0000 0000 0000 0000 0011 
-----------------------------------------------
// OR = 0000 0000 0000 0000 0000 0000 0001 1011 
```



#### 按位异或（XOR）

按位异或操作符 `^`，也有两个操作数。以下是按位异或的真值表。

![image-20220521130337370](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/myBlog/image-20220521130337370.png)

这个操作在两个数值对应位上只有一个 1 时才返回 1，如果对应的两位都是 1 或都是 0，则返回 0。 

对 25 和 3 执行按位异或操作的代码如下所示：

```js
var result = 25 ^ 3; 

alert(result); //26 

//  25 = 0000 0000 0000 0000 0000 0000 0001 1001 
//  3  = 0000 0000 0000 0000 0000 0000 0000 0011 
----------------------------------------------- 
// XOR = 0000 0000 0000 0000 0000 0000 0001 1010 
```

二进制码 11010 等于十进制值 26（注意这个结果比执行按位或时小 1）。



#### 左移`<<`

左移操作符 `<<` 表示，这个操作符会将数值的所有位向左移动指定的位数。

```js
var oldValue = 2; // 等于二进制的 10 

var newValue = oldValue << 5; // 等于二进制的 1000000，十进制的 64 
```

注意，在向左移位后，原数值的右侧多出了 5 个空位。左移操作会以 0 来填充这些空位，以便得到的结果是一个完整的 32 位二进制数（见图 3-2）。

![image-20220521130634200](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/myBlog/image-20220521130634200.png)

注意，左移不会影响操作数的符号位。换句话说，如果将 -2 向左移动 5 位，结果将是-64，而非 64。



#### 有符号的右移 `>>`

有符号的右移操作符 `>>` 表示，这个操作符会将数值向右移动，但保留符号位（即正负号标记）。有符号的右移操作与左移操作恰好相反，即如果将 64 向右移动 5 位，结果将变回 2：

```js
var oldValue = 64; // 等于二进制的 1000000 

var newValue = oldValue >> 5; // 等于二进制的 10 ，即十进制的 2 
```

同样，在移位过程中，原数值中也会出现空位。只不过这次的空位出现在原数值的左侧、符号位的右侧（见图 3-3）。而此时 ECMAScript 会用符号位的值来填充所有空位，以便得到一个完整的值。

![image-20220521130917658](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/myBlog/image-20220521130917658.png)

#### 无符号右移 `>>>`

无符号右移操作符 `>>>` 表示，这个操作符会将数值的所有 32 位都向右移动。

对正数来说，无符号右移的结果与有符号右移相同。仍以前面有符号右移的代码为例，如果将 64 无符号右移 5 位，结果仍然还是 2：

```js
var oldValue = 64; // 等于二进制的 1000000 

var newValue = oldValue >>> 5; // 等于二进制的 10 ，即十进制的 2 
```

但是对负数来说，情况就不一样了。首先，无符号右移是以 0 来填充空位，而不是像有符号右移那样以符号位的值来填充空位。

其次，无符号右移操作符会把负数的二进制码当成正数的二进制码。而且，由于负数以其绝对值的二进制补码形式表示，因此就会导致无符号右移后的结果非常之大，如下面的例子所示：

```js
var oldValue = -64; // -64的二进制11111111111111111111111111000000

var newValue = oldValue >>> 5; // 00000111111111111111111111111110 等于十进制的 134217726 
```

这里，当对-64 执行无符号右移 5 位的操作后，得到的结果是 134217726。之所以结果如此之大，



### 3.5.3 布尔操作符

布尔操作符一共有 3 个：非（NOT）、与（AND）和或（OR）。

#### 逻辑非

逻辑非操作符 `！`表示，可以应用于 ECMAScript 中的任何值。无论这个值是什么数据类型，这个操作符都会返回一个布尔值。

逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再对其求反。

- 如果操作数是一个对象，返回 false； 
- 如果操作数是一个空字符串，返回 true； 
- 如果操作数是一个非空字符串，返回 false； 
- 如果操作数是数值 0，返回 true； 
- 如果操作数是任意非 0 数值（包括 Infinity），返回 false； 
- 如果操作数是 null，返回 true； 
- 如果操作数是 NaN，返回 true； 
- 如果操作数是 undefined，返回 true。

而同时使用两个逻辑非操作符，实际上就会模拟 Boolean()转型函数的行为。其中，第一个逻辑非操作会基于无论什么操作数返回一个布尔值，而第二个逻辑非操作则对该布尔值求反，于是就得到了这个值真正对应的布尔值。

```js
alert(!!"blue"); //true 
alert(!!0); //false 
alert(!!NaN); //false 
alert(!!""); //false 
alert(!!12345); //true
```



#### 逻辑与

逻辑与操作符由两个和号 `&& `表示，有两个操作数，如下面的例子所示：

```js
var result = true && false; 
```

逻辑与的真值表如下：

![image-20220521133922628](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/myBlog/image-20220521133922628.png)

逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。

在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值；此时，它遵循下列规则：

- 如果第一个操作数是对象，则返回第二个操作数；
- 如果第二个操作数是对象，则只有在第一个操作数的求值结果为 true 的情况下才会返回该对象；
- 如果两个操作数都是对象，则返回第二个操作数；
- 如果有一个操作数是 null，则返回 null； 
- 如果有一个操作数是 NaN，则返回 NaN； 
- 如果有一个操作数是 undefined，则返回 undefined。

逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。

```js
var found = true; 

var result = (found && someUndefinedVariable); // 这里会发生错误

alert(result); // 这一行不会执行
```

由于变量 found 的值是 true，会继续对变量 someUndefinedVariable 求值。但 someUndefinedVariable 尚未定义，因此就会导致错误。这说明不能在逻辑与操作中使用未定义的值。

如果像下面这个例中一样，将 found 的值设置为 false，就不会发生错误了：

```js
var found = false;

var result = (found && someUndefinedVariable); // 不会发生错误

alert(result); // 会执行（"false"）
```

根本用不着再对&&右侧的操作数求值了。在使用逻辑与操作符时要始终铭记它是一个短路操作符。



#### 逻辑或

逻辑或操作符由两个竖线符号 `||`表示，有两个操作数，如下面的例子所示：

```js
var result = true || false; 
```

逻辑或的真值表如下：

![image-20220521134344557](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/myBlog/image-20220521134344557.png)

与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值；此时，它遵循下列规则：

- 如果第一个操作数是对象，则返回第一个操作数；
- 如果第一个操作数的求值结果为 false，则返回第二个操作数；
- 如果两个操作数都是对象，则返回第一个操作数；
- 如果两个操作数都是 null，则返回 null； 
- 如果两个操作数都是 NaN，则返回 NaN； 
- 如果两个操作数都是 undefined，则返回 undefined。

逻辑或操作符也是短路操作符。也就是说，如果第一个操作数的求值结果为true，就不会对第二个操作数求值了。

```js
var found = true; 

var result = (found || someUndefinedVariable); // 不会发生错误

alert(result); // 会执行（"true"）
```

把 found 的值改为 false，就会导致错误：

```js
var found = false;** 

var result = (found || someUndefinedVariable); // 这里会发生错误

alert(result); // 这一行不会执行
```

可以利用逻辑或的这一行为来避免为变量赋 null 或 undefined 值

```js
var myObject = preferredObject || backupObject; 
```

如果 preferredObject 的值不是 null，那么它的值将被赋给 myObject；如果是 null，则将 backupObject 的值赋给 myObject。



### 3.5.4 乘性操作符

ECMAScript 定义了 3 个乘性操作符：乘法、除法和求模。

在操作数为非数值的情况下会执行自动的类型转换。如果参与乘性计算的某个操作数不是数值，后台会先使用 Number()转型函数将其转换为数值。



#### 乘法

```js
var result = 34 * 56; 
```

如果乘积超过了 ECMAScript 数值的表示范围，则返回 Infinity 或-Infinity； 

- 如果有一个操作数是 NaN，则结果是 NaN； 
- 如果是 Infinity 与 0 相乘，则结果是 NaN； 
- 如果是 Infinity 与非 0 数值相乘，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号；
- 如果是 Infinity 与 Infinity 相乘，则结果是 Infinity； 
- 如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。



#### 除法

```js
var result = 66 / 11;
```

如果商超过了 ECMAScript 数值的表示范围，则返回 Infinity 或-Infinity； 

- 如果有一个操作数是 NaN，则结果是 NaN； 
- 如果是 Infinity 被 Infinity 除，则结果是 NaN； 
- 如果是零被零除，则结果是 NaN； 
- 如果是非零的有限数被零除，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号；
- 如果是 Infinity 被任何非零数值除，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号；
- 如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。



#### 求模

```js
var result = 26 % 5; // 等于 1 
```

与另外两个乘性操作符类似，求模操作符会遵循下列特殊规则来处理特殊的值：

- 如果操作数都是数值，执行常规的除法计算，返回除得的余数；
- 如果被除数是无穷大值而除数是有限大的数值，则结果是 NaN； 
- 如果被除数是有限大的数值而除数是零，则结果是 NaN； 
- 如果是 Infinity 被 Infinity 除，则结果是 NaN； 
- 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数；
- 如果被除数是零，则结果是零；
- 如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。



### 3.5.5 加性操作符

加性操作符也会在后台转换不同的数据类型。然而，对于加性操作符而言，相应的转换规则还稍微有点复杂。

#### 加法

如果两个操作符都是数值，执行常规的加法计算，然后根据下列规则返回结果：

- 如果有一个操作数是 NaN，则结果是 NaN； 
- 如果是 Infinity 加 Infinity，则结果是 Infinity； 
- 如果是-Infinity 加-Infinity，则结果是-Infinity； 
- 如果是 Infinity 加-Infinity，则结果是 NaN； 
- 如果是+0 加+0，则结果是+0； 
- 如果是-0 加-0，则结果是-0； 
- 如果是+0 加-0，则结果是+0。

不过，如果有一个操作数是字符串，那么就要应用如下规则：

- 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；
- 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来。

如果有一个操作数是对象、数值或布尔值，则调用它们的 toString()方法取得相应的字符串值。对于 undefined 和 null，则分别调用 String()函数并取得字符串"undefined"和"null"。

```js
var result1 = 5 + 5; // 两个数值相加
alert(result1); // 10 

var result2 = 5 + "5"; // 一个数值和一个字符串相加
alert(result2); // "55"
```

忽视加法操作中的数据类型是 ECMAScript 编程中最常见的一个错误。

```js
var num1 = 5; 
var num2 = 10; 

var message = "The sum of 5 and 10 is " + num1 + num2; 
alert(message); // "The sum of 5 and 10 is 510" 
```

如果想先对数值执行算术计算，应该像下面这样使用圆括号：

```js
var num1 = 5; 
var num2 = 10; 

var message = "The sum of 5 and 10 is " + (num1 + num2); 
alert(message); //"The sum of 5 and 10 is 15" 
```

#### 减法

如果两个操作符都是数值，则执行常规的算术减法操作并返回结果；

- 如果有一个操作数是 NaN，则结果是 NaN； 
- 如果是 Infinity 减 Infinity，则结果是 NaN； 
- 如果是-Infinity 减-Infinity，则结果是 NaN； 
- 如果是 Infinity 减-Infinity，则结果是 Infinity； 
- 如果是-Infinity 减 Infinity，则结果是-Infinity； 
- 如果是+0 减+0，则结果是+0； 
- 如果是+0 减-0，则结果是-0；
- 如果是-0 减-0，则结果是+0； 
- 如果有一个操作数是字符串、布尔值、null 或 undefined，则先在后台调用 Number()函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是 NaN，则减法的结果就是 NaN； 
- 如果有一个操作数是对象，则调用对象的 valueOf()方法以取得表示该对象的数值。如果得到的值是 NaN，则减法的结果就是 NaN。如果对象没有 valueOf()方法，则调用其 toString()方法并将得到的字符串转换为数值。

```js
var result1 = 5 - true; // 4，因为 true 被转换成了 1 
var result2 = NaN - 1; // NaN 
var result3 = 5 - 3; // 2 
var result4 = 5 - ""; // 5，因为"" 被转换成了 0 
var result5 = 5 - "2"; // 3，因为"2"被转换成了 2 
var result6 = 5 - null; // 5，因为 null 被转换成了 0
```



### 3.5.6 关系操作符

小于（<）、大于（>）、小于等于（<=）和大于等于（>=）这几个关系操作符用于对两个值进行比较。

```js
var result1 = 5 > 3; //true 

var result2 = 5 < 3; //false 
```

与 ECMAScript 中的其他操作符一样，当关系操作符的操作数使用了非数值时，也要进行数据转换或完成某些奇怪的操作。

- 如果两个操作数都是数值，则执行数值比较。
- 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。
- 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。
- 如果一个操作数是对象，则调用这个对象的 valueOf()方法。如果对象没有 valueOf()方法，则调用 toString()方法，并用得到的结果根据前面的规则执行比较。
- 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。

在比较字符串时，实际比较的是两个字符串中对应位置的每个字符的字符编码值。由于大写字母的字符编码全部小于小写字母的字符编码，因此我们就会看到如下所示的奇怪现象：

```js
var result = "Brick" < "alphabet"; //true 
```

在这个例子中，字符串"Brick"被认为小于字符串"alphabet"。原因是字母 B 的字符编码为 66，而字母 a 的字符编码是 97。

如果要真正按字母表顺序比较字符串，就必须把两个操作数转换为相同的大小写形式（全部大写或全部小写），然后再执行比较：

```js
var result = "Brick".toLowerCase() < "alphabet".toLowerCase(); //false 
```

另一种奇怪的现象发生在比较两个数字字符串的情况下，比如下面这个例子：

```js
var result = "23" < "3"; //true 
```

确实，当比较字符串"23"是否小于"3"时，结果居然是 true。这是因为两个操作数都是字符串，而字符串比较的是字符编码（"2"的字符编码是 50，而"3"的字符编码是 51）。不过，将一个操作数改为数值，比较的结果就正常了：

```js
var result = "23" < 3; //false 
```

此时，字符串"23"会被转换成数值 23，然后再与 3 进行比较，因此就会得到合理的结果。

当然，这个规则对前面的例子是适用的。可是，如果那个字符串不能被转换成一个合理的数值呢？

```js
var result = "a" < 3; // false，因为"a"被转换成了 NaN 
```

由于字母"a"不能转换成合理的数值，因此就被转换成了 NaN。

根据规则，任何操作数与 NaN 进行关系比较，结果都是 false。于是，就出现了下面这个有意思的现象：

```js
var result1 = NaN < 3; //false 

var result2 = NaN >= 3; //false 
```



### 3.5.7 相等操作符



#### 相等和不相等

相等操作符由两个等于号（==）表示，而不相等操作符由叹号后跟等于号（!=）表示。这两个操作符都会先转换操作数（通常称为强制转型），然后再比较它们的相等性。

在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则：

- 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false 转换为 0，而true 转换为 1；
- 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；
- 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法，用得到的基本类型值按照前面的规则进行比较；

这两个操作符在进行比较时则要遵循下列规则。

- null 和 undefined 是相等的。
- 要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。
- 如果有一个操作数是 NaN，则相等操作符返回 false，而不相等操作符返回 true。即使两个操作数都是 NaN，相等操作符也返回 false。
- 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true；否则，返回 false。

下表列出了一些特殊情况及比较结果：

![image-20220521141230350](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/myBlog/image-20220521141230350.png)



#### 全等和不全等

全等操作符由 3 个等于号（===）表示，它只在两个操作数未经转换就相等的情况下返回 true，如下面的例子所示：

```js
var result1 = ("55" == 55); //true，因为转换后相等

var result2 = ("55" === 55); //false，因为不同的数据类型不相等
```

不全等操作符由一个叹号后跟两个等于号（!==）表示，它在两个操作数未经转换就不相等的情况下返回 true。例如：

```js
var result1 = ("55" != 55); //false，因为转换后相等

var result2 = ("55" !== 55); //true，因为不同的数据类型不相等
```

记住：null == undefined 会返回 true，因为它们是类似的值；但 null === undefined 会返 false，因为它们是不同类型的值。

> 由于相等和不相等操作符存在类型转换问题，而为了保持代码中数据类型的完整性，我们推荐使用全等和不全等操作符。





### 3.5.8 条件操作符

```js
variable = boolean_expression ? true_value : false_value; 
```

本质上，这行代码的含义就是基于对 boolean_expression 求值的结果，决定给变量 variable赋什么值。如果求值结果为 true，则给变量 variable 赋 true_value 值；如果求值结果为 false，则给变量 variable 赋 false_value 值。

合理利用三元条件操作符，能极大简化代码



### 3.5.9 赋值操作符

简单的赋值操作符由等于号（=）表示，其作用就是把右侧的值赋给左侧的变量，如下面的例子所示：

```js
var num = 10; 
```

复合赋值操作

```js
var num = 10; 
num = num + 10; 

var num = 10; 
num += 10; 
```

每个主要算术操作符（以及个别的其他操作符）都有对应的复合赋值操作符。这些操作符如下所示：

* 乘/赋值（*=）
* 除/赋值（/=）
* 模/赋值（%=）
* 加/赋值（+=）
* 减/赋值（-=）
* 左移/赋值（<<=）
* 有符号右移/赋值（>>=）
* 无符号右移/赋值（>>>=）



### 3.5.10 逗号操作符

使用逗号操作符可以在一条语句中执行多个操作。

```js
var num1=1, num2=2, num3=3; 
```

逗号操作符多用于声明多个变量；但除此之外，逗号操作符还可以用于赋值。在用于赋值时，逗号操作符总会返回表达式中的最后一项，如下面的例子所示：

```js
var num = (5, 1, 4, 8, 0); // num 的值为 0 
```

由于 0 是表达式中的最后一项，因此 num 的值就是 0。虽然逗号的这种使用方式并不常见，但这个例子可以帮我们理解逗号的这种行为。



## 3.6 语句



### 3.6.1 if语句

大多数编程语言中最为常用的一个语句就是if 语句

```javascript
if (i > 25)
		alert("Greater than 25."); // 单行语句
else {
		alert("Less than or equal to 25."); // 代码块中的语句
}
```

> 业界普遍推崇的最佳实践是始终使用代码块



### 3.6.2 do-while语句

do-while 语句是一种后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件

> 像do-while 这种后测试循环语句最常用于循环体中的代码至少要被执行一次的情形

```javascript
do {
	statement
} while (expression)
  
// 下面是一个示例：
var i = 0; 
do { 
 i += 2; 
} while (i < 10); 
alert(i);
```



### 3.6.3 while语句

while 语句属于前测试循环语句，也就是说，在循环体内的代码被执行之前，就会对出口条件求值

```java
while(expression){
  statement
} 
```



### 3.6.4 for语句

for 语句也是一种前测试循环语句，但它具有在执行循环之前初始化变量和定义循环后要执行的代码的能力

```javascript
for (initialization; expression; post-loop-expression){
  statement
} 
```

下面是一个示例：

```js
var count = 10; 
for (var i = 0; i < count; i++){ 
 		alert(i); 
} 
```

以上代码定义了变量 i 的初始值为 0。只有当条件表达式（i<count）返回 true 的情况下才会进入 for 循环，因此也有可能不会执行循环体中的代码。如果执行了循环体中的代码，则一定会对循环后的表达式（i++）求值，即递增 i 的值。这个 for 循环语句与下面的 while 语句的功能相同：

```js
var count = 10; 
var i = 0; 

while (i < count){ 
 	alert(i); 
 	i++; 
} 
```

使用 while 循环做不到的，使用 for 循环同样也做不到。也就是说，for 循环只是把与循环有关的代码集中在了一个位置。

有必要指出的是，在 for 循环的变量初始化表达式中，也可以不使用 var 关键字。该变量的初始化可以在外部执行，例如：

```js
var count = 10; 
var i; 
for (i = 0; i < count; i++){
 		alert(i); 
} 
```

因此在循环内部定义的变量也可以在外部访问到。例如：

```js
var count = 10; 
for (var i = 0; i < count; i++){ 
		alert(i); 
} 

alert(i); //10
```

在这个例子中，会有一个警告框显示循环完成后变量 i 的值，这个值是 10。这是因为，即使 i 是在循环内部定义的一个变量，但在循环外部仍然可以访问到它。

此外，for 语句中的初始化表达式、控制表达式和循环后表达式都是可选的。将这三个表达式全部省略，就会创建一个无限循环，例如：

```js
for (;;) { // 无限循环
 		doSomething(); 
} 
```

而只给出控制表达式实际上就把 for 循环转换成了 while 循环

```js
var count = 10; 
var i = 0; 
for (; i < count; ){ 
 		alert(i); 
 		i++; 
} 
```

由于 for 语句存在极大的灵活性，因此它也是 ECMAScript 中最常用的一个语句。



### 3.6.5 for-in语句

for-in 语句是一种精准的迭代语句，可以用来枚举**对象的属性**

```javascript
for (var propName in window) {
	document.write(propName);
}
```

> 与 for 语句类似，这里控制语句中的 var 操作符也不是必需的。但是，为了保证使用局部变量，我们推荐上面例子中的这种做法。

ECMAScript 对象的属性没有顺序。因此，通过 for-in 循环输出的属性名的顺序是不可预测的。所有属性都会被返回一次，但返回的先后次序可能会因浏览器而异。



### 3.6.6 label语句

使用label 语句可以在代码中添加标签，以便将来使用

```javascript
label: statement
```

下面是一个示例：

```javascript
start: for (var i=0; i < count; i++) {
	alert(i)
}
```

这个例子中定义的start 标签可以在将来由break 或continue 语句引用。加标签的语句一般都要与for 语句等循环语句配合使用



### 3.6.7 break和continue语句

break 和 continue 语句用于在循环中精确地控制代码的执行。

其中，break 语句会立即退出循环，强制继续执行循环后面的语句。

而 continue 语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行，进入下一次循环。

break 和 continue 语句都可以与 label 语句联合使用，从而返回代码中特定的位置。这种联合使用的情况多发生在循环嵌套的情况下，如下面的例子所示：

```js
var num = 0; 
outermost: 
for (var i=0; i < 10; i++) { 
 	for (var j=0; j < 10; j++) { 
   	if (i == 5 && j == 5) { 
 				break outermost; 
 		} 
 		num++; 
 	} 
} 

alert(num); //55 
```

在这个例子中，outermost 标签表示外部的 for 语句。如果每个循环正常执行 10 次，则 num++

语句就会正常执行 100 次。换句话说，如果两个循环都自然结束，num 的值应该是 100。但内部循环中的 break 语句带了一个参数：要返回到的标签。添加这个标签的结果将导致 break 语句不仅会退出内部的 for 语句（即使用变量 j 的循环），而且也会退出外部的 for 语句（即使用变量 i 的循环）。

为此，当变量 i 和 j 都等于 5 时，num 的值正好是 55。同样，continue 语句也可以像这样与 label 语句联用。

```js
var num = 0; 
outermost: 
for (var i=0; i < 10; i++) { 
 	for (var j=0; j < 10; j++) { 
 		if (i == 5 && j == 5) { 
 				continue outermost; 
 		} 
 		num++; 
 } 
} 

alert(num); //95 
```

在这种情况下，continue 语句会强制继续执行循环——退出内部循环，执行外部循环。当 j 是 5时，continue 语句执行，而这也就意味着内部循环少执行了 5 次，因此 num 的结果是 95。

虽然联用 break、continue 和 label 语句能够执行复杂的操作，但如果使用过度，也会给调试带来麻烦。在此，我们建议如果使用 label 语句，一定要使用描述性的标签，同时不要嵌套过多的循环。



### 3.6.8 with语句

with 语句的作用是将代码的作用域设置到一个特定的对象中。with 语句的语法如下：

```js
with (expression) statement; 
```

定义 with 语句的目的主要是为了简化多次编写同一个对象的工作，如下面的例子所示：

```js
var qs = location.search.substring(1); 
var hostName = location.hostname; 
var url = location.href; 
```

上面几行代码都包含 location 对象。如果使用 with 语句，可以把上面的代码改写成如下所示：

```js
with(location){ 
 var qs = search.substring(1); 
 var hostName = hostname; 
 var url = href; 
} 
```

在这个重写后的例子中，使用 with 语句关联了 location 对象。这意味着在 with 语句的代码块内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询location 对象中是否有同名的属性。如果发现了同名属性，则以 location 对象属性的值作为变量的值。

严格模式下不允许使用 with 语句，否则将视为语法错误。

> 由于大量使用 **with** 语句会导致性能下降，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用 **with** 语句。



### 3.6.9 switch语句

switch 语句在比较值时使用的是**全等操作符**，不会发生类型转换

```javascript
switch (expression) {
	case value: statement
		break;
	case value: statement
		break;
	case value: statement
		break;
	case value: statement
		break;
    default: statement
    	break;
}
```

通过为每个 case 后面都添加一个 break 语句，就可以避免同时执行多个 case 代码的情况。假如确实需要混合几种情形，不要忘了在代码中添加注释,说明你是有意省略了 break 关键字，如下所示：

```javascript
switch (i) {
	case 25:
	/* 合并两种情形 */
	case 35:
		alert("25 or 35");
		break;
	case 45:
		alert("45");
		break;
	default:
		alert("Other");
}
```

虽然 ECMAScript 中的 switch 语句借鉴自其他语言，但JavaScript中的switch也有自己的特色

首先，可以在switch 语句中使用任何数据类型，无论是字符串，还是对象都没有问题。其次，每个case 的值不一定是常量，可以是变量，甚至是表达式。请看下面这个例子：

```javascript
switch ("hello world") {
	case "hello" + " world":
		alert("Greeting was found.");
		break;
	case "goodbye":
		alert("Closing was found.");
		break;
	default:
		alert("Unexpected message was found.");
}
```

使用表达式：

```javascript
var num = 25;
switch (true) {
	case num < 0:
		alert("Less than 0.");
		break;
	case num >= 0 && num <= 10:
		alert("Between 0 and 10.");
		break;
	case num > 10 && num <= 20:
		alert("Between 10 and 20.");
		break;
	default:
		alert("More than 20.");
}
```

这个例子首先在 switch 语句外面声明了变量 num。而之所以给 switch 语句传递表达式 true，是因为每个 case 值都可以返回一个布尔值。这样，每个 case 按照顺序被求值，直到找到匹配的值或者遇到 default 语句为止（这正是这个例子的最终结果）。

> switch 语句在比较值时使用的是全等操作符，因此不会发生类型转换（例如，字符串"10"不等于数值 10）。



## 3.7 函数

函数对任何语言来说都是一个核心的概念。通过函数可以封装任意多条语句，而且可以在任何地方、任何时候调用执行。

函数的基本语法如下所示：

```javascript
function functionName(arg0, arg1,...,argN) {
		statements
}
```

以下是一个函数示例：

```js
function sayHi(name, message) { 
 		alert("Hello " + name + "," + message); 
} 
```

ECMAScript 中的函数在定义时不必指定是否返回值。实际上，任何函数在任何时候都可以通过return 语句后跟要返回的值来实现返回值。请看下面的例子：

```js
function sum(num1, num2) { 
 		return num1 + num2; 
} 
```

这个函数会在执行完 return 语句之后停止并立即退出。因此，位于 return 语句之后的任何代码都永远不会执行。

另外，return 语句也可以不带有任何返回值。在这种情况下，函数在停止执行后将返undefined值。这种用法一般用在需要提前停止函数执行而又不需要返回值的情况下。

```js
function sayHi(name, message) { 
 		return;
		alert("Hello " + name + "," + message); //永远不会调用
} 
```

推荐的做法是要么让函数始终都返回一个值，要么永远都不要返回值。否则，如果函数有时候返回值，有时候有不返回值，会给调试代码带来不便。

严格模式对函数有一些限制：

- 不能把函数命名为 eval 或 arguments； 
- 不能把参数命名为 eval 或 arguments； 
- 不能出现两个命名参数同名的情况。

如果发生以上情况，就会导致语法错误，代码无法执行。



### 3.7.1理解参数

ECMAScript 函数不介意传递进来多少个参数，也不在乎传进来参数是什么数据类型。也就是说，即便你定义的函数只接收两个参数，在调用这个函数时也未必一定要传递两个参数。可以传递一个、三个甚至不传递参数。

之所以会这样，原因是 ECMAScript 中的参数在内部是用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数。

实际上，在函数体内可以通过 arguments 对象来访问这个参数数组，从而获取传递给函数的每一个参数。

其实，arguments 对象只是与数组类似（它并不是 Array 的实例），因为可以使用方括号语法访问它的每一个元素（即第一个元素是 arguments[0]，第二个元素是 argumetns[1]，以此类推），使用 length 属性来确定传递进来多少个参数。

```js
function sayHi() { 
		alert("Hello " + arguments[0] + "," + arguments[1]); 
} 
```

这个重写后的函数中不包含命名的参数。虽然没有使用 name 和 message 标识符，但函数的功能依旧。这个事实说明了 ECMAScript 函数的一个重要特点：命名的参数只提供便利，但不是必需的。另外，在命名参数方面，其他语言可能需要事先创建一个函数签名，而将来的调用必须与该签名一致。

但在 ECMAScript 中，没有这些条条框框，解析器不会验证命名参数。通过访问 arguments 对象的 length 属性可以获知有多少个参数传递给了函数。下面这个函数会在每次被调用时，输出传入其中的参数个数：

```js
function howManyArgs() { 
		alert(arguments.length); 
} 

howManyArgs("string", 45); //2 
howManyArgs(); //0 
howManyArgs(12); //1 
```

由此可见，开发人员可以利用这一点让函数能够接收任意个参数并分别实现适当的功能。请看下面的例子：

```js
function doAdd() { 
		if(arguments.length == 1) { 
 				alert(arguments[0] + 10); 
 		} else if (arguments.length == 2) { 
 				alert(arguments[0] + arguments[1]); 
 		} 
} 

doAdd(10); //20 
doAdd(30, 20); //50 
```

虽然这个特性算不上完美的重载，但也足够弥补 ECMAScript 的这一缺憾了。

另一个与参数相关的重要方面，就是 arguments 对象可以与命名参数一起使用，如下面的例子所示：

```js
function doAdd(num1, num2) { 
		if(arguments.length == 1) {
				alert(num1 + 10); 
		} else if (arguments.length == 2) { 
				alert(arguments[0] + num2); 
 		}
} 
```

在重写后的这个 doAdd()函数中，两个命名参数都与 arguments 对象一起使用。由于 num1 的值与 arguments[0]的值相同，因此它们可以互换使用（当然，num2 和 arguments[1]也是如此）。



关于 arguments 的行为，还有一点比较有意思。那就是它的值永远与对应命名参数的值保持同步。

```js
function doAdd(num1, num2) { 
		arguments[1] = 10; 
		alert(arguments[0] + num2); 
} 
```

每次执行这个 doAdd()函数都会重写第二个参数，将第二个参数的值修改为 10。因为arguments对象中的值会自动反映到对应的命名参数，所以修改 arguments[1]，也就修改了 num2，结果它们的值都会变成 10。

不过，这并不是说读取这两个值会访问相同的内存空间；它们的内存空间是独立的，但它们的值会同步。

另外还要记住，如果只传入了一个参数，那么为 arguments[1]设置的值不会反应到命名参数中。这是因为 arguments 对象的长度是由传入的参数个数决定的，不是由定义函数时的命名参数的个数决定的。

关于参数还要记住最后一点：没有传递值的命名参数将自动被赋予 undefined 值。这就跟定义了变量但又没有初始化一样。例如，如果只给 doAdd()函数传递了一个参数，则 num2 中就会保存undefined 值。

严格模式对如何使用 arguments 对象做出了一些限制。首先，像前面例子中那样的赋值会变得无效。也就是说，即使把 arguments[1]设置为 10，num2 的值仍然还是 undefined。其次，重写arguments 的值会导致语法错误（代码将不会执行）。

>ECMAScript 中的所有参数传递的都是值，不可能通过引用传递参数。



### 3.7.2 没有重载

如果在ECMAScript 中定义了两个名字相同的函数，则该名字只属于后定义的函数

```javascript
function addSomeNumber(num){
	return num + 100;
}
function addSomeNumber(num) {
	return num + 200;
}
var result = addSomeNumber(100); //300
```

如前所述，通过检查传入函数中参数的类型和数量并作出不同的反应，可以**模仿**方法的重载



## 3.8 小结

JavaScript 的核心语言特性在 ECMA-262 中是以名为 ECMAScript 的伪语言的形式来定义的。

ECMAScript 中包含了所有基本的语法、操作符、数据类型以及完成基本的计算任务所必需的对象，但没有对取得输入和产生输出的机制作出规定。

理解 ECMAScript 及其纷繁复杂的各种细节，是理解其在Web 浏览器中的实现——JavaScript 的关键。目前大多数实现所遵循的都是 ECMA-262 第 3 版，但很多也已经着手开始实现第 5 版了。以下简要总结了 ECMAScript 中基本的要素。

- ECMAScript 中的基本数据类型包括 Undefined、Null、Boolean、Number 和 String。 
- 与其他语言不同，ECMScript 没有为整数和浮点数值分别定义不同的数据类型，Number 类型可用于表示所有数值。
- ECMAScript 中也有一种复杂的数据类型，即 Object 类型，该类型是这门语言中所有对象的基础类型。
- 严格模式为这门语言中容易出错的地方施加了限制。
- ECMAScript 从其他语言中借鉴了很多流控制语句，例如 if 语句、for 语句和 switch 语句等。
- ECMAScript 中的函数与其他语言中的函数有诸多不同之处。
- 无须指定函数的返回值，因为任何 ECMAScript 函数都可以在任何时候返回任何值。
- 实际上，未指定返回值的函数返回的是一个特殊的 undefined 值。
- ECMAScript 中也没有函数签名的概念，因为其函数参数是以一个包含零或多个值的数组的形式传递的。
- 可以向 ECMAScript 函数传递任意数量的参数，并且可以通过 arguments 对象来访问这些参数。
- 由于不存在函数签名的特性，ECMAScript 函数不能重载。