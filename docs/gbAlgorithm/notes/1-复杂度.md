---
title: 复杂度分析
date: '2022-06-10 12:53:00'
sidebar: 'true'
categories:
  - java
tags:
  - 数据结构
  - 算法
  - 极客
---





复杂度分析是整个算法学习的精髓

执行代码，通过统计、监控，就能得到算法执行的时间和占用的内存大小。这种评估算法执行效率的方法是正确的的，但很多数据结构和算法的书籍叫“事后统计法”。但这种方法有很大局限性。

## 事后统计法局限性

- 测试结果非常依赖测试环境
  - 例如，同样一段代码，分别用 Intel Core i9 处理器和 Intel Core i3 处理器来运行，i9 处理器要比 i3 处理器执行的速度快很多。

- 测试结果受数据规模的影响很大
  - 对同一个排序算法，待排序数据的有序度不一样，排序的执行时间就会有很大的差别。
  - 除此之外，如果测试数据规模太小，测试结果可能无法真实地反映算法的性能。比如，对于小规模的数据排序，插入排序可能反倒会比快速排序要快！

## 时间复杂度

算法的执行时间与数据规模之间的增长关系

### 1.只关注循环执行次数最多的

```java
int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i <= n; ++i) {
     sum = sum + i;
   }
   return sum;
 }
```

其中第 2、3 行代码都是常量级的执行时间，与 n 的大小无关，所以对于复杂度并没有影响。循环执行次数最多的是第 4、5 行代码，这两行代码被执行了 n 次，所以总的时间复杂度就是 O(n)。

### 2. 加法法则：

总复杂度等于量级最大的那段代码的复杂度

```java
int cal(int n) {
   int sum_1 = 0;
   int p = 1;
   for (; p < 100; ++p) {
     sum_1 = sum_1 + p;
   }

   int sum_2 = 0;
   int q = 1;
   for (; q < n; ++q) {
     sum_2 = sum_2 + q;
   }
 
   int sum_3 = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1; 
     for (; j <= n; ++j) {
       sum_3 = sum_3 +  i * j;
     }
   }
 
   return sum_1 + sum_2 + sum_3;
 }
```

我们可以分别分析每一部分的时间复杂度，然后把它们放到一块儿，再取一个量级最大的作为整段代码的复杂度。

将这个规律抽象成公式就是：如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n))).

### 3. 乘法法则：

嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n)).

假设 T1(n) = O(n)，T2(n) = O(n²)，则 T1(n) * T2(n) = O(n³)。

```java
int cal(int n) {
   int ret = 0; 
   int i = 1;
   for (; i < n; ++i) {
     ret = ret + f(i);
   } 
 } 
 
int f(int n) {
  int sum = 0;
  int i = 1;
  for (; i < n; ++i) {
    sum = sum + i;
  } 
  return sum;
}
```

整个 cal() 函数的时间复杂度就是，T(n) = T1(n) * T2(n) = O(n*n) = O(n²)。

### 常见的复杂度

![](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/myBlog/202208171222074.png)

### 特殊的复杂度

O(m+n)、O(m*n)

讲一种跟前面都不一样的时间复杂度，代码的复杂度由两个数据的规模来决定

```java
int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
```

m 和 n 是表示两个数据规模。无法事先评估 m 和 n 谁的量级大，所以在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。

所以，上面代码的时间复杂度就是 O(m+n)。我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))。

但是乘法法则继续有效：T1(m)*T2(n) = O(f(m) * f(n))。

## 空间复杂度

表示算法的存储空间与数据规模之间的增长关系。

```java
void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i <n; ++i) {
    a[i] = i * i;
  }

  for (i = n-1; i >= 0; --i) {
    print out a[i]
  }
}
```

第 2 行代码中，我们申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。

第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。

我们常见的空间复杂度就是 O(1)、O(n)、O(n² )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。

而且，空间复杂度分析比时间复杂度分析要简单很多。掌握这些内容已经足够了。



## 最好、最坏情况时间复杂度

```java
// n 表示数组array的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) pos = i;
  }
  return pos;
}
```

这段代码要实现的功能是，在一个无序的数组（array）中，查找变量 x 出现的位置。如果没有找到，就返回 -1。这段代码的复杂度是 O(n);

在数组中查找一个数据，并不需要每次都把整个数组都遍历一遍，可能中途找到就可以提前结束循环了

```java
// n 表示数组array的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}
```

查找的变量 x 可能出现在数组的任意位置。如果数组中第一个元素正好是要查找的变量 x，那时间复杂度就是 O(1)

如果数组中不存在变量 x，就需要把整个数组都遍历一遍，时间复杂度就成了 O(n)

为了表示代码在不同情况下的不同时间复杂度，我们需要引入三个概念：

- 最好情况时间复杂度、
- 最坏情况时间复杂度
- 平均情况时间复杂度。

## 平均情况时间复杂度

为了更好地表示平均情况下的复杂度，我们需要引入另一个概念：平均情况时间复杂度。

平均时间复杂度又该怎么分析呢？我还是借助刚才查找变量 x 的例子来给你解释。要查找的变量 x 在数组中的位置，有 n+1 种情况：在数组的 0～n-1 位置中和不在数组中。我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n+1，就可以得到需要遍历的元素个数的平均值，即：

![img](https://interview-aliyun.oss-cn-beijing.aliyuncs.com/myBlog/202208171227975.jpg)

这个公式简化之后，得到的平均时间复杂度就是 O(n)。

我们知道，要查找的变量 x，要么在数组里，要么就不在数组里。

为了方便你理解，我们假设在数组中与不在数组中的概率都为 1/2。另外，要查找的数据出现在 0～n-1 这 n 个位置的概率也是一样的，为 1/n。

所以，根据概率乘法法则，要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)。

<img src="https://interview-aliyun.oss-cn-beijing.aliyuncs.com/myBlog/202208171227004.jpg" alt="img" style="zoom:150%;" />

引入概率之后，前面那段代码的加权平均值为 (3n+1)/4。这段代码的加权平均时间复杂度仍然是 O(n)。

在大多数情况下，我们并不需要区分最好、最坏、平均情况时间复杂度三种情况。

很多时候，我们使用一个复杂度就可以满足需求了。只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分。





















































